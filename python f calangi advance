class Animal:
     def speak (self):
       return " Some generic animal sound"

class Dog (Animal):
    def speak (self)
      return "Woof! Woof!"

class Cat (Animal):
      def speak (self):
         return "Meow!"

  dog = Dog ()
  cat = Cat ()

print (dog.speak())
print (cat.speak())

  class Vehicle:
      def_init_(self,brand,fuel):
       self.brand = brand
       self.fuel = fuel
class Car (Vehicle):
  def_init_(self,brand,fuel,doors):
  super()._init_(brand,fuel)
  self.doors = doors
def drive (self):
  if self.fuel>0:
    self.fuel -= 1
  return f"{self.brand} is driving. Remaining fuel:{self.fuel}"
else:
   return f"{self.brand} is out of fuel."
my_car = Car("Toyota",5,4)
print(my.car.drive())
print(my.car.drive())

 class BankAccount:
   def_init_(self, balance>0):
     self._balance= balance
 def deposit (self, amount):
   if amount> 0:
     self._ balance += amount
 def withdraw (self,amount):
   if amount <- self.balance-= amount
else:
   print("Insufficient funds")
def get_balance (self):
   return self._balance
account= Bank account (100)
account.deposit (50)
account.withdraw(30)
print("Current balance", account.get_balance())

 class Person:
   def_init_(self,age):
       self.age= age
   def age(self):
       return self._age
    def age(self,value):
       if insistance(value,int)and value >0:
         self._age = value
else:
     raise valueError("Age must be a positive integer.")
person = person(25)
   print("Age:",person.age)
person.age= 30
   print("Updated age:",person.age)

 class InkPrinter:
   defprint_document (self):
     return "Printing document using inkjet technology..."
 class Laser Printer:
     def print_document(self):
      return"Printing document using laser technology..."
 ink= InkPrinter()
 laser= LaserPrinter()
print(ink.print_document())
print(laser.primt_document())

 defmake_it_speak(obj):
    obj.speak()
 class Bird:
    def speak(self):
     print("Chirp! Chirp!")
 class Robot:
    def speak(self):
     print("Beep boop!")
  bird= Bird()
  robot= Robot()
   make_it_speak(bird)
   make_it_speak(robot)

class Shape (ABC):
  def area (self):
   pass
class Circle (Shape):
  def_init_(self, radius):
    self.radius= radius
  def area (self):
    return 3.14*self.radius**2
class Rectangle (Shape):
  def_init_(self,width,height):
    self.width= width
    self.height= height
  def area (self):
    return self.width*self.height
circle= Circle (5)
rectangle= Rectangle(4,6)
print=("Circle area:",circle.area())
print=("Rectangle area:", rectangle.area())

 class Employee(ABC):
  def calculate_pay(self):
      pass
 class Hourly Employee (Employee):
  def_init_(self,hours_worked,hourly_rate):
  self.hours_worked=hours_worked
  self.hourly_rate= hourly_rate
 defcalculate_pay(self):
    return self.hours_worked*self.hourly_rate
 class Salaried Employee (Employee):
   def_init_(self,monthly_salary):
     self.monthly_salary= monthly_salary
   def calculate_pay(self):
     return slef.month_salary
hourly_emp= Hourly Employee (40,150)
salaried_emp= Salaried Employee (30000)
print("Hourly Employee Pay:",hourly_emp.calculate_pay())
print("Salaried Employee Pay:",salaried_emp.calculate_pay())

class Node:
   def_init_(self,data):
     self.data= data
     self.next= None
class LinkedList:
   def_init_(self):
     self.head= None
   def append (self,data):
     new_node= Node(data)
     if not self.head:
        self.head= new_node
        return
     current= self.head
     while current.next:
        current.next= new_node
   def prepend (self,data):
     new_node= Node (data)
     new_node.next= self.head
     self.head= new_node
   def delete (self,key):
     current= self.head
    if current and current.data== key:
      self.head= current.next
      return
    prev= None
      while current and current.data!= key:
        prev= current
      current= current.next
      if current is None:
        print(f"{key} not found!")
        return
      prev.next= current.next
   def search (self,key):
      current= self.head
      while current:
         if current.data== key:
           return True
         current= current.next
           return False
    def count (self):
       count= 0
       current= self.head
       while current:
           count+=1
           current= current.next
        return count
    def reverse (self):
       prev= None
       current= self.head
       while current:
         next= current.next
       current.next= prev
         prev= current
         current= next
       self.head= prev
    def display (self):
        current= self.head
        while current:
          print(current.data end="-> ")
          current= current.next
          print ("None")

class Node:
  def_init_(self,data):
     self.data= data
     self.next= None
class Stack
  def_init_(self):
     self.top= None
     self.count= 0
  def push(self,data):
     new_node= Node(data)
     new_node.next= self.top
     self.top= new_node
     self.count += 1
     print(f"{data} onto the stack.")
  def pop(self):
     if self.top is None:
       print("Stack Underflow! Cannot pop from empty stack.")
       return None
     popped_data= self.top.data
     self.top= self.top.next
     self.count-= 1
     print (f"Popped{popped_data} from the stack.")
     return popped_data
  def peek(self):
     if slef.top is None:
       print ("Stack is empty.")
       return None
     primt(f"Top element is{self.top.data}")
       return self.top.data
  def is_empty(self):
       return self.top is None
  def size(self):
       return self.count
  def display(self):
       if self.top is None
         print ("Stack is empty.")
         return
       current= self.top
       print(" Stack elements(top to bottom):",end="")
       while current:
            print ( current.data,end="->")
            current= current.next
       print("None")




      
