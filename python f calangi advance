class Animal:
     def speak (self):
       return " Some generic animal sound"

class Dog (Animal):
    def speak (self)
      return "Woof! Woof!"

class Cat (Animal):
      def speak (self):
         return "Meow!"

  dog = Dog ()
  cat = Cat ()

print (dog.speak())
print (cat.speak())

  class Vehicle:
      def_init_(self,brand,fuel):
       self.brand = brand
       self.fuel = fuel
class Car (Vehicle):
  def_init_(self,brand,fuel,doors):
  super()._init_(brand,fuel)
  self.doors = doors
def drive (self):
  if self.fuel>0:
    self.fuel -= 1
  return f"{self.brand} is driving. Remaining fuel:{self.fuel}"
else:
   return f"{self.brand} is out of fuel."
my_car = Car("Toyota",5,4)
print(my.car.drive())
print(my.car.drive())

 class BankAccount:
   def_init_(self, balance>0):
     self._balance= balance
 def deposit (self, amount):
   if amount> 0:
     self._ balance += amount
 def withdraw (self,amount):
   if amount <- self.balance-= amount
else:
   print("Insufficient funds")
def get_balance (self):
   return self._balance
account= Bank account (100)
account.deposit (50)
account.withdraw(30)
print("Current balance", account.get_balance())

 class Person:
   def_init_(self,age):
       self.age= age
   def age(self):
       return self._age
    def age(self,value):
       if insistance(value,int)and value >0:
         self._age = value
else:
     raise valueError("Age must be a positive integer.")
person = person(25)
   print("Age:",person.age)
person.age= 30
   print("Updated age:",person.age)

 class InkPrinter:
   defprint_document (self):
     return "Printing document using inkjet technology..."
 class Laser Printer:
     def print_document(self):
      return"Printing document using laser technology..."
 ink= InkPrinter()
 laser= LaserPrinter()
print(ink.print_document())
print(laser.primt_document())

 defmake_it_speak(obj):
    obj.speak()
 class Bird:
    def speak(self):
     print("Chirp! Chirp!")
 class Robot:
    def speak(self):
     print("Beep boop!")
  bird= Bird()
  robot= Robot()
   make_it_speak(bird)
   make_it_speak(robot)

class Shape (ABC):
  def area (self):
   pass
class Circle (Shape):
  def_init_(self, radius):
    self.radius= radius
  def area (self):
    return 3.14*self.radius**2
class Rectangle (Shape):
  def_init_(self,width,height):
    self.width= width
    self.height= height
  def area (self):
    return self.width*self.height
circle= Circle (5)
rectangle= Rectangle(4,6)
print=("Circle area:",circle.area())
print=("Rectangle area:", rectangle.area())

 class Employee(ABC):
  def calculate_pay(self):
      pass
 class Hourly Employee (Employee):
  def_init_(self,hours_worked,hourly_rate):
  self.hours_worked=hours_worked
  self.hourly_rate= hourly_rate
 defcalculate_pay(self):
    return self.hours_worked*self.hourly_rate
 class Salaried Employee (Employee):
   def_init_(self,monthly_salary):
     self.monthly_salary= monthly_salary
   def calculate_pay(self):
     return slef.month_salary
hourly_emp= Hourly Employee (40,150)
salaried_emp= Salaried Employee (30000)
print("Hourly Employee Pay:",hourly_emp.calculate_pay())
print("Salaried Employee Pay:",salaried_emp.calculate_pay())

class Node:
   def_init_(self,data):
     self.data= data
     self.next= None
class LinkedList:
   def_init_(self):
     self.head= None
   def append (self,data):
     new_node= Node(data)
     if not self.head:
        self.head= new_node
        return
     current= self.head
     while current.next:
        current.next= new_node
   def prepend (self,data):
     new_node= Node (data)
     new_node.next= self.head
     self.head= new_node
   def delete (self,key):
     current= self.head
    if current and current.data== key:
      self.head= current.next
      return
    prev= None
      while current and current.data!= key:
        prev= current
      current= current.next
      if current is None:
        print(f"{key} not found!")
        return
      prev.next= current.next
   def search (self,key):
      current= self.head
      while current:
         if current.data== key:
           return True
         current= current.next
           return False
    def count (self):
       count= 0
       current= self.head
       while current:
           count+=1
           current= current.next
        return count
    def reverse (self):
       prev= None
       current= self.head
       while current:
         next= current.next
       current.next= prev
         prev= current
         current= next
       self.head= prev
    def display (self):
        current= self.head
        while current:
          print(current.data end="-> ")
          current= current.next
          print ("None")

class Node:
  def_init_(self,data):
     self.data= data
     self.next= None
class Stack
  def_init_(self):
     self.top= None
     self.count= 0
  def push(self,data):
     new_node= Node(data)
     new_node.next= self.top
     self.top= new_node
     self.count += 1
     print(f"{data} onto the stack.")
  def pop(self):
     if self.top is None:
       print("Stack Underflow! Cannot pop from empty stack.")
       return None
     popped_data= self.top.data
     self.top= self.top.next
     self.count-= 1
     print (f"Popped{popped_data} from the stack.")
     return popped_data
  def peek(self):
     if slef.top is None:
       print ("Stack is empty.")
       return None
     primt(f"Top element is{self.top.data}")
       return self.top.data
  def is_empty(self):
       return self.top is None
  def size(self):
       return self.count
  def display(self):
       if self.top is None
         print ("Stack is empty.")
         return
       current= self.top
       print(" Stack elements(top to bottom):",end="")
       while current:
            print ( current.data,end="->")
            current= current.next
       print("None")

class Queue:
      def_init_(self):
       self.items = []
      def enqueue(self,items):
       self.items.append(item)
      def dequeue(self):
       if not self.is_empty():
        return self.items.pop(0)
       return"Queue is empty"
      def peek(self):
       if not self.is_empty():
        return self.items[0]
       return "Queue is empty"
      def is_empty(self):
       return len(self.items) ==0
      def size(self):
       return len(self.items)
print("Queue:",q.items)
print("Dequeued:",q.dequeue())
print("Front:",q.peek())
print("Size:",q.size())

class BST
    def_init_(self):
       self.root = None
    def insert(self,value):
       self.root = self._insert(self.root,value)
    def_insert(self,root,value):
       if root is None:
         return Node(value)
       if value < root.value:
         root.left = self._insert(root.left,value)
    else:
       root.right = self._insert(root.right,value)
    return root

import tkinter as tk
from tkinter import messagebox


def validate_login():
    userid = username_entry.get()
    password = password_entry.get()


    if userid == "admin" and password == "password":
        messagebox.showinfo("Login Successful", "Welcome, Admin!")
    else:
        messagebox.showerror("Login Failed", "Invalid username or password")


parent = tk.Tk()
parent.title("Login Form")


username_label = tk.Label(parent, text="Userid:")
username_label.pack()

username_entry = tk.Entry(parent)
username_entry.pack()


password_label = tk.Label(parent, text="Password:")
password_label.pack()

password_entry = tk.Entry(parent, show="*")  # Show asterisks for password
password_entry.pack()


login_button = tk.Button(parent, text="Login", command=validate_login)
login_button.pack()


parent.mainloop()

# Basic Mathematical Operations in Python


num1 = float(input("Enter the first number: "))
num2 = float(input("Enter the second number: "))


add = num1 + num2
print(f"{num1} + {num2} = {add}")


sub = num1 - num2
print(f"{num1} - {num2} = {sub}")


mul = num1 * num2
print(f"{num1} * {num2} = {mul}")


if num2 != 0:
    div = num1 / num2
    print(f"{num1} / {num2} = {div}")
else:
    print("Division by zero is not allowed.")


if num2 != 0:
    floor_div = num1 // num2
    print(f"{num1} // {num2} = {floor_div}")


if num2 != 0:
    mod = num1 % num2
    print(f"{num1} % {num2} = {mod}")


exp = num1 ** num2
print(f"{num1} ** {num2} = {exp}")

# Basic input operation 

name = input("Enter your name: ")
age = input("Enter your age: ")
number1 = int(input("Enter first number: "))
number2 = int(input("Enter second number: "))

# Processing
sum_result = number1 + number2

# Output
print("\n--- OUTPUT ---")
print("Hello,", name)
print("Your age is:", age)
print("The sum of the two numbers is:", sum_result)

# String Functions 
text = "Hello World"

print("Original String:", text)
print("Lowercase:", text.lower())
print("Uppercase:", text.upper())
print("Title Case:", text.title())
print("Length of string:", len(text))
print("Replace 'World' with 'Python':", text.replace("World", "Python"))
print("Index of 'o':", text.find("o"))

import math

print("Absolute value of -15:", abs(-15))
print("Factorial of 5:", math.factorial(5))
print("Remainder of 17 divided by 3:", math.fmod(17, 3))









      
